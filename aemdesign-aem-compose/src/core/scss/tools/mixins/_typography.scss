/// Generates a `@font-face` declaration.
/// @see https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face
/// @author Chris Shaw
/// @group typography
/// @since 1.0.0
/// @param {String} $name - Font family name
/// @param {String} $path - Path to the font files
/// @param {Number} $weight [null] - Font weight
/// @param {String} $style [null] - Font style
/// @param {List} $exts [woff2 woff] - List of file extensions
/// @example
///   @include font-face(
///     'Open Sans',
///     'open-sans/open-sans-v15-latin-300',
///     300,
///     normal
///   );
///
///   @include font-face(
///     'Open Sans',
///     'open-sans/open-sans-v15-latin-300',
///     $exts: woff2
///   );
/// @output `@font-face` declaration
@mixin font-face($name, $path, $weight: null, $style: null, $exts: woff2 woff) {
  $src: '#{$asset-base-path}fonts/';

  $extmods: (
    eot: '?',
    svg: '#' + str-replace($name, ' ', '_'),
  );

  $formats: (
    otf: 'opentype',
    ttf: 'truetype',
  );

  @each $ext in $exts {
    $extmod: if(map-has-key($extmods, $ext), $ext + map-get($extmods, $ext), $ext);
    $format: if(map-has-key($formats, $ext), map-get($formats, $ext), $ext);
    $src: append($src, url(quote($path + '.' + $extmod)) format(quote($format)), comma);
  }

  @font-face {
    font-family: quote($name);
    font-style: $style;
    font-weight: $weight;
    src: $src;
  }
}

/// ...
/// @group typography
/// @since 1.0.0
@mixin typography-level($for, $key) {
  $config: map-deep-get($typography, $for, $key);
  @include typography-style($key, $config, true);
}

/// ...
/// @group typography
/// @since 1.0.0
@mixin typography-style($level, $config, $styles-only: false) {
  $selector: $level;

  // Determine if this style needs a base selector in addition to a class
  $no-tag: map-has-key($config, no-tag) and map-get($config, no-tag) == true;
  $no-default: not map-has-key($config, default-selector);

  // Change the `$selector` so it reflects the default if one is set
  @if not $no-default {
    $selector: unquote(map-get($config, default-selector));
  }

  // Should the selector be extended?
  @if map-has-key($config, extend-to) {
    $selector: unquote('#{$selector}, #{map-get($config, extend-to)}');
  }

  // Loop through each breakpoint and set the styles
  @each $breakpoint, $size in $grid-breakpoints {
    @if map-has-key($config, $breakpoint) {
      $break-config: map-get($config, $breakpoint);

      @if map-has-key($break-config, only) and map-get($break-config, only) == true {
        @include media-breakpoint-only($breakpoint) {
          @include typography-bp($selector, $level, $no-tag, $no-default, $break-config, $styles-only);
        }
      }
      @else {
        @include media-breakpoint-up($breakpoint) {
          @include typography-bp($selector, $level, $no-tag, $no-default, $break-config, $styles-only);
        }
      }
    }
  }
}

/// ...
/// @group typography
/// @since 1.0.0
@mixin typography-bp(
  $selector,
  $level,
  $no-tag,
  $no-default,
  $break-config,
  $styles-only: false
) {
  @if $styles-only == true {
    @include typography-styles($break-config);
  }
  @else if $no-tag and $no-default {
    .#{$level} {
      @include typography-styles($break-config);
    }
  }
  @else {
    #{$selector},
    .#{$level} {
      @include typography-styles($break-config);
    }
  }
}

/// ...
/// @group typography
/// @since 1.0.0
@mixin typography-styles($config) {
  @each $key, $value in $config {
    @if $key != 'only' {
      #{$key}: #{$value};
    }
  }
}
